package id_generator

import (
	"bytes"
	"fmt"
	"log"
	"math/rand"
	"os"
	"strings"
	"time"
)

type LogTranceIdGenerator interface {
	Generate() string
}

// RandomIdGenerator
// ID Generator that is used to generate random IDs.
//
// The IDs generated by this class are not absolutely unique,
// but the probability of duplication is very low.
//
type RandomIdGenerator struct {
}

func (r *RandomIdGenerator) Generate() string {
	var id string
	subStrOfHostName := r.getLastFieldOfHostName()
	curMs := time.Now().UnixMilli()
	randSuffix := r.generateRandomAlphameric(8)

	id = fmt.Sprintf("%s-%d-%s", subStrOfHostName, curMs, randSuffix)

	return id
}

func (r *RandomIdGenerator) getLastFieldOfHostName() string {
	var subStrOfHostName string = "null"
	host, err := os.Hostname()
	if err != nil {
		log.Printf("failed to get hostname:%s", err)
	} else {
		subStrOfHostName = r.getLastFieldSplitByDot(host)
	}

	return subStrOfHostName
}

// 抽象出此方法 方便测试
func (r *RandomIdGenerator) getLastFieldSplitByDot(str string) string {
	cuts := strings.Split(str, ".")

	return cuts[len(cuts)-1]
}

// Generate random string
// which only contains digits, uppercase letters and lowercase letters.
//
// @param length should not be less than 0
// @return the random string. Returns empty string if {@length} is 0
func (r *RandomIdGenerator) generateRandomAlphameric(length int) string {
	var buf = new(bytes.Buffer)
	for i := 0; i < length; {
		randAscii := rand.Int31n('z')
		isDigit := randAscii >= '0' && randAscii <= '9'
		isUpperCase := randAscii >= 'A' && randAscii <= 'Z'
		isLowerCase := randAscii >= 'a' && randAscii <= 'z'

		if isDigit || isUpperCase || isLowerCase {
			buf.WriteByte(byte(randAscii))
			i++
		}
	}

	return buf.String()
}
